---
title: "A minimal example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mwe}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


This vignette demonstrates how to use `centrality` on a small, undirected graph with unweighted edges and no self-loops. The simulated graph describes the connectivity of 10 nodes, described by an adjacency matrix $A_{n\times n}$ ($n=10$). 
We want to evaluate how influential each node is through computations of its centrality measures, in particular the [degree centrality](https://en.wikipedia.org/wiki/Centrality#Degree_centrality), [closeness centrality](https://en.wikipedia.org/wiki/Closeness_centrality), and [betweeness centrality](https://en.wikipedia.org/wiki/Betweenness_centrality) (or eigenvector centrality, depending on which one I manage to debug. The eigenvector centrality seems less likely though). 


```{r setup}
library(centrality)
library('RColorBrewer')
library(igraph)
library(gplots)
library(knitr)
library(fields)
set.seed(1)
```

# Data Simulation: 

```{r}
n = 10
# A.mat = sim_deg_conn(n, 0.1)
A.mat = sim_adjacency(n)
A.graph = graph_from_adjacency_matrix(A.mat, mode = "undirected")
graph <- simplify(A.graph, remove.multiple = F)
```


# Network Visualization

## Adjacency Matrix

```{r, fig.width=4, fig.height=4}
# plot adjacency matrix
par(cex.main=0.8)
colors = rep(brewer.pal(9, "Blues"), each = 3)[1:17]
plot.A.mat = A.mat + diag(rep(2, 10))    # emphasize diagonal in plot
adj.mat = heatmap.2(plot.A.mat, dendrogram='none', Rowv=FALSE, Colv=FALSE, trace='none', 
          key = F, col = as.vector(colors), main = "Adjacency Matrix", 
          colsep = 1:10, rowsep = 1:10, sepcolor = "grey", sepwidth=c(0.005,0.005))
image.plot(legend.only=T, zlim=range(0,1), col=colors)
```


## Network Visualization

```{r, fig.width=4, fig.height=4}
# plot network
set.seed(1)
network = plot(graph, vertex.label=1:n, vertex.size=15, main = "Simulated Network")
```

## Calculate and visualize degree centrality: 

```{r}
# calculate degree centrality:
c.deg.std = degree(A.mat) 

# plot degree centrality
set.seed(1)
V(graph)$order = c.deg.std
V(graph)$color = rgb((colorRamp(c("blue", "red"))(V(graph)$order))/255)
plot(graph, vertex.label=1:n, vertex.size=15, main = "Degree Centrality")
image.plot(legend.only=T, zlim=range(c.deg.std), col=sort(V(graph)$color))
```

## Calculate and visualize closeness centrality: 

```{r}
# calculate closeness centrality:
c.deg.std = closeness(A.mat) 

# plot degree centrality
set.seed(1)
V(graph)$order = c.deg.std
V(graph)$color = rgb((colorRamp(c("blue", "red"))(V(graph)$order))/255)
plot(graph, vertex.label=1:n, vertex.size=15, main = "Closeness Centrality")
# legend(1,1,fill = V(graph)$color, legend = V(graph)$order)
image.plot(legend.only=T, zlim=range(c.deg.std), col=sort(V(graph)$color))
```


## Session information

Here are some details about the computing environment, including the
versions of R, and the R packages, used to generate these results.

```{r}
sessionInfo()
```

